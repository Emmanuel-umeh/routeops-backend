/*
------------------------------------------------------------------------------
This code was generated by Amplication.

Changes to this file will be lost if the code is regenerated.

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import * as nestAccessControl from "nest-access-control";
import * as defaultAuthGuard from "../../auth/defaultAuth.guard";
import { ProjectService } from "../project.service";
import { PrismaService } from "../../prisma/prisma.service";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { ProjectCreateInput } from "./ProjectCreateInput";
import { Project } from "./Project";
import { ProjectFindManyArgs } from "./ProjectFindManyArgs";
import { ProjectWhereUniqueInput } from "./ProjectWhereUniqueInput";
import { ProjectUpdateInput } from "./ProjectUpdateInput";
import { HazardFindManyArgs } from "../../hazard/base/HazardFindManyArgs";
import { Hazard } from "../../hazard/base/Hazard";
import { HazardWhereUniqueInput } from "../../hazard/base/HazardWhereUniqueInput";
import { RoutePointFindManyArgs } from "../../routePoint/base/RoutePointFindManyArgs";
import { RoutePoint } from "../../routePoint/base/RoutePoint";
import { RoutePointWhereUniqueInput } from "../../routePoint/base/RoutePointWhereUniqueInput";
import { SurveyFindManyArgs } from "../../survey/base/SurveyFindManyArgs";
import { Survey } from "../../survey/base/Survey";
import { SurveyWhereUniqueInput } from "../../survey/base/SurveyWhereUniqueInput";
import { applyEntityScope, isAdminUser } from "../../util/entityScope.util";
import { EnumProjectStatus } from "./EnumProjectStatus";

@swagger.ApiBearerAuth()
@common.UseGuards(defaultAuthGuard.DefaultAuthGuard, nestAccessControl.ACGuard)
export class ProjectControllerBase {
  constructor(
    protected readonly service: ProjectService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder,
    protected readonly prisma: PrismaService
  ) {}
  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Project })
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "create",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async createProject(
    @common.Body() data: ProjectCreateInput
  ): Promise<Project> {
    return await this.service.createProject({
      data: {
        ...data,

        cityHall: data.cityHall
          ? {
              connect: data.cityHall,
            }
          : undefined,
      },
      select: {
        assignedUser: true,

        cityHall: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        createdBy: true,
        description: true,
        id: true,
        name: true,
        status: true,
        updatedAt: true,
        videoUrl: true,
        videoMetadata: {
          select: {
            id: true,
            videoTime: true,
            lat: true,
            lng: true,
            createdAt: true,
          },
          orderBy: {
            videoTime: "asc",
          },
        },
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get()
  @swagger.ApiOkResponse({ type: [Project] })
  @ApiNestedQuery(ProjectFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "read",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async projects(@common.Req() request: Request): Promise<any[]> {
    const { standardQuery, filters } = this.service.parseProjectFilters(
      request.query as Record<string, unknown>
    );
    const args = plainToClass(ProjectFindManyArgs, standardQuery);
    const argsWithFilters: ProjectFindManyArgs = {
      ...args,
      where: this.service.applyProjectFilters(args.where as any, filters),
    };

    // Determine requester and scope by cityHall for non-admins
    const authUser = (request as any).user as { id: string; roles: string[] };
    const scopedWhere = await applyEntityScope(this.prisma, authUser, argsWithFilters.where as any);

    // Exclude projects with active status
    const finalWhere = {
      ...scopedWhere,
      status: {
        not: EnumProjectStatus.ACTIVE,
      },
    };

    const projects = await this.service.projects({
      ...argsWithFilters,
      where: finalWhere,
      orderBy: argsWithFilters.orderBy || [{ createdAt: "desc" }],
      select: {
        assignedUser: true,

        cityHall: {
          select: {
            id: true,
            name: true,
            description: true,
            allowVideo: true,
            allowImages: true,
            createdAt: true,
            updatedAt: true,
          },
        },

        createdAt: true,
        createdBy: true,
        description: true,
        id: true,
        name: true,
        status: true,
        updatedAt: true,
        videoUrl: true,
        videoMetadata: {
          select: {
            id: true,
            videoTime: true,
            lat: true,
            lng: true,
            createdAt: true,
          },
          orderBy: {
            videoTime: "asc",
          },
        },
        surveys: {
          select: {
            id: true,
            name: true,
            status: true,
            startTime: true,
            endTime: true,
            geometryJson: true,
            bbox: true,
            eIriAvg: true,
            lengthMeters: true,
            createdAt: true,
            updatedAt: true,
          },
          take: 10, // Limit to first 10 surveys for performance
          orderBy: {
            createdAt: "desc",
          },
        },
        routePoints: {
          select: {
            id: true,
            latitude: true,
            longitude: true,
            timestamp: true,
            frameNumber: true,
            createdAt: true,
            updatedAt: true,
          },
          take: 20, // Limit to first 20 route points for performance
          orderBy: {
            timestamp: "asc",
          },
        },
        hazards: {
          select: {
            id: true,
            latitude: true,
            longitude: true,
            description: true,
            severity: true,
            typeField: true,
            imageUrl: true,
            createdAt: true,
            updatedAt: true,
          },
          take: 20, // Limit to first 20 hazards for performance
          orderBy: {
            createdAt: "desc",
          },
        },
      },
    });

    // Fetch user details for createdBy and assignedUser
    const userIds = new Set<string>();
    projects.forEach((project: any) => {
      if (project.createdBy) userIds.add(project.createdBy);
      if (project.assignedUser) userIds.add(project.assignedUser);
    });

    const users = await this.prisma.user.findMany({
      where: { id: { in: Array.from(userIds) } },
      select: {
        id: true,
        username: true,
        firstName: true,
        lastName: true,
        email: true,
      },
    });

    const userMap = new Map(users.map(u => [u.id, u]));

    // Enrich projects with user information
    return projects.map((project: any) => ({
      ...project,
      createdByUser: project.createdBy ? userMap.get(project.createdBy) || null : null,
      assignedUserInfo: project.assignedUser ? userMap.get(project.assignedUser) || null : null,
    }));
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Project })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "read",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async project(
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<any | null> {
    // Determine requester and scope access for non-admins
    const request = (arguments[0] as any) as Request | undefined;
    let whereClause: any = params;
    try {
      // attempt to read user from request context
      // note: in Nest, switchToHttp isn't available here, so rely on interceptor-populated request arg when present
      const reqUser = (request as any)?.user as { id: string; roles: string[] } | undefined;
      const isAdmin = isAdminUser(reqUser);
      if (!isAdmin && reqUser?.id) {
        whereClause = await applyEntityScope(this.prisma, reqUser, whereClause as any);
      }
    } catch (_) {
      // fall back to unscoped where if user not available
    }

    const result = await this.service.project({
      where: whereClause,
      select: {
        assignedUser: true,

        cityHall: {
          select: {
            id: true,
            name: true,
            description: true,
            allowVideo: true,
            allowImages: true,
            createdAt: true,
            updatedAt: true,
          },
        },

        createdAt: true,
        createdBy: true,
        description: true,
        id: true,
        name: true,
        status: true,
        updatedAt: true,
        videoUrl: true,
        videoMetadata: {
          select: {
            id: true,
            videoTime: true,
            lat: true,
            lng: true,
            createdAt: true,
          },
          orderBy: {
            videoTime: "asc",
          },
        },
        surveys: {
          select: {
            id: true,
            name: true,
            status: true,
            startTime: true,
            endTime: true,
            geometryJson: true,
            bbox: true,
            eIriAvg: true,
            lengthMeters: true,
            createdAt: true,
            updatedAt: true,
          },
        },
        routePoints: {
          select: {
            id: true,
            latitude: true,
            longitude: true,
            frameNumber: true,
            timestamp: true,
            createdAt: true,
            updatedAt: true,
          },
        },
        hazards: {
          select: {
            id: true,
            typeField: true,
            severity: true,
            description: true,
            latitude: true,
            longitude: true,
            imageUrl: true,
            createdAt: true,
            updatedAt: true,
          },
        },
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }

    // Fetch user details for createdBy and assignedUser
    const userIds: string[] = [];
    if ((result as any).createdBy) userIds.push((result as any).createdBy);
    if ((result as any).assignedUser) userIds.push((result as any).assignedUser);

    let createdByUser = null;
    let assignedUserInfo = null;

    if (userIds.length > 0) {
      const users = await this.prisma.user.findMany({
        where: { id: { in: userIds } },
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
          email: true,
        },
      });

      const userMap = new Map(users.map(u => [u.id, u]));
      createdByUser = (result as any).createdBy ? userMap.get((result as any).createdBy) || null : null;
      assignedUserInfo = (result as any).assignedUser ? userMap.get((result as any).assignedUser) || null : null;
    }

    return {
      ...result,
      createdByUser,
      assignedUserInfo,
    };
  }

  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Project })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async updateProject(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() data: ProjectUpdateInput
  ): Promise<Project | null> {
    try {
      // Check if project exists and is pending (only pending projects can be edited)
      const existingProject = await this.service.project({
        where: params,
        select: { id: true, status: true },
      });

      if (!existingProject) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }

      // Only allow editing pending projects
      if (existingProject.status !== EnumProjectStatus.PENDING) {
        throw new common.BadRequestException(
          "Only pending projects can be edited"
        );
      }

      // Convert date strings to Date objects if provided
      const updateData: any = {
        ...data,
        cityHall: data.cityHall
          ? {
              connect: data.cityHall,
            }
          : undefined,
      };

      if (data.scheduledDate !== undefined) {
        updateData.scheduledDate = data.scheduledDate
          ? new Date(data.scheduledDate)
          : null;
      }

      if (data.startDate !== undefined) {
        updateData.startDate = data.startDate ? new Date(data.startDate) : null;
      }

      return await this.service.updateProject({
        where: params,
        data: updateData,
        select: {
          assignedUser: true,
          cityHall: {
            select: {
              id: true,
            },
          },
          createdAt: true,
          createdBy: true,
          description: true,
          id: true,
          name: true,
          status: true,
          scheduledDate: true,
          startDate: true,
          updatedAt: true,
          videoUrl: true,
          videoMetadata: {
            select: {
              id: true,
              videoTime: true,
              lat: true,
              lng: true,
              createdAt: true,
            },
            orderBy: {
              videoTime: "asc",
            },
          },
        },
      });
    } catch (error) {
      if (error instanceof errors.NotFoundException || error instanceof common.BadRequestException) {
        throw error;
      }
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Project })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "delete",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async deleteProject(
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<Project | null> {
    try {
      return await this.service.deleteProject({
        where: params,
        select: {
          assignedUser: true,

          cityHall: {
            select: {
              id: true,
            },
          },

          createdAt: true,
          createdBy: true,
          description: true,
          id: true,
          name: true,
          status: true,
          updatedAt: true,
          videoUrl: true,
          videoMetadata: {
            select: {
              id: true,
              videoTime: true,
              lat: true,
              lng: true,
              createdAt: true,
            },
            orderBy: {
              videoTime: "asc",
            },
          },
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/hazards")
  @ApiNestedQuery(HazardFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Hazard",
    action: "read",
    possession: "own",
  })
  async findHazards(
    @common.Req() request: Request,
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<Hazard[]> {
    const query = plainToClass(HazardFindManyArgs, request.query);
    const authUser = (request as any).user as { id: string; roles: string[] };
    const isAdmin = Array.isArray(authUser?.roles) && authUser.roles.includes("admin");
    if (!isAdmin) {
      // Verify the project is within the user's city hall before returning hazards
      const [project, user] = await Promise.all([
        this.prisma.project.findUnique({ where: { id: params.id }, select: { cityHallId: true } }),
        this.prisma.user.findUnique({ where: { id: authUser?.id }, select: { cityHallId: true } }),
      ]);
      if (!project) {
        throw new errors.NotFoundException(`No resource was found for ${JSON.stringify(params)}`);
      }
      if (!user?.cityHallId || user.cityHallId !== project.cityHallId) {
        throw new errors.ForbiddenException("Insufficient privileges to complete the operation");
      }
    }
    const results = await this.service.findHazards(params.id, {
      ...query,
      select: {
        createdAt: true,
        createdBy: true,
        description: true,
        id: true,
        imageUrl: true,
        latitude: true,
        longitude: true,

        project: {
          select: {
            id: true,
          },
        },

        routePoint: {
          select: {
            id: true,
          },
        },

        severity: true,
        typeField: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/hazards")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async connectHazards(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: HazardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hazards: {
        connect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/hazards")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async updateHazards(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: HazardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hazards: {
        set: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/hazards")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async disconnectHazards(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: HazardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hazards: {
        disconnect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/routePoints")
  @ApiNestedQuery(RoutePointFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "RoutePoint",
    action: "read",
    possession: "any",
  })
  async findRoutePoints(
    @common.Req() request: Request,
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<RoutePoint[]> {
    const query = plainToClass(RoutePointFindManyArgs, request.query);
    const results = await this.service.findRoutePoints(params.id, {
      ...query,
      select: {
        createdAt: true,
        frameNumber: true,
        id: true,
        latitude: true,
        longitude: true,

        project: {
          select: {
            id: true,
          },
        },

        timestamp: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/routePoints")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async connectRoutePoints(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: RoutePointWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routePoints: {
        connect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/routePoints")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async updateRoutePoints(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: RoutePointWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routePoints: {
        set: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/routePoints")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async disconnectRoutePoints(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: RoutePointWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routePoints: {
        disconnect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/surveys")
  @ApiNestedQuery(SurveyFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Survey",
    action: "read",
    possession: "any",
  })
  async findSurveys(
    @common.Req() request: Request,
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<Survey[]> {
    const query = plainToClass(SurveyFindManyArgs, request.query);
    const results = await this.service.findSurveys(params.id, {
      ...query,
      select: {
        assignedUser: true,
        createdAt: true,
        endTime: true,
        id: true,
        name: true,

        project: {
          select: {
            id: true,
          },
        },

        remarks: true,
        startTime: true,
        status: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/surveys")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async connectSurveys(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: SurveyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      surveys: {
        connect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/surveys")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async updateSurveys(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: SurveyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      surveys: {
        set: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/surveys")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async disconnectSurveys(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: SurveyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      surveys: {
        disconnect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }
}

