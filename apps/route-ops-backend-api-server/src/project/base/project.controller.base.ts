/*
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/how-to/custom-code

------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as swagger from "@nestjs/swagger";
import { isRecordNotFoundError } from "../../prisma.util";
import * as errors from "../../errors";
import { Request } from "express";
import { plainToClass } from "class-transformer";
import { ApiNestedQuery } from "../../decorators/api-nested-query.decorator";
import * as nestAccessControl from "nest-access-control";
import * as defaultAuthGuard from "../../auth/defaultAuth.guard";
import { ProjectService } from "../project.service";
import { PrismaService } from "../../prisma/prisma.service";
import { AclValidateRequestInterceptor } from "../../interceptors/aclValidateRequest.interceptor";
import { AclFilterResponseInterceptor } from "../../interceptors/aclFilterResponse.interceptor";
import { ProjectCreateInput } from "./ProjectCreateInput";
import { Project } from "./Project";
import { ProjectFindManyArgs } from "./ProjectFindManyArgs";
import { ProjectWhereUniqueInput } from "./ProjectWhereUniqueInput";
import { ProjectUpdateInput } from "./ProjectUpdateInput";
import { HazardFindManyArgs } from "../../hazard/base/HazardFindManyArgs";
import { Hazard } from "../../hazard/base/Hazard";
import { HazardWhereUniqueInput } from "../../hazard/base/HazardWhereUniqueInput";
import { RoutePointFindManyArgs } from "../../routePoint/base/RoutePointFindManyArgs";
import { RoutePoint } from "../../routePoint/base/RoutePoint";
import { RoutePointWhereUniqueInput } from "../../routePoint/base/RoutePointWhereUniqueInput";
import { SurveyFindManyArgs } from "../../survey/base/SurveyFindManyArgs";
import { Survey } from "../../survey/base/Survey";
import { SurveyWhereUniqueInput } from "../../survey/base/SurveyWhereUniqueInput";
import { applyEntityScope, isAdminUser } from "../../util/entityScope.util";

@swagger.ApiBearerAuth()
@common.UseGuards(defaultAuthGuard.DefaultAuthGuard, nestAccessControl.ACGuard)
export class ProjectControllerBase {
  constructor(
    protected readonly service: ProjectService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder,
    protected readonly prisma: PrismaService
  ) {}
  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Post()
  @swagger.ApiCreatedResponse({ type: Project })
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "create",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async createProject(
    @common.Body() data: ProjectCreateInput
  ): Promise<Project> {
    return await this.service.createProject({
      data: {
        ...data,

        cityHall: data.cityHall
          ? {
              connect: data.cityHall,
            }
          : undefined,
      },
      select: {
        assignedUser: true,

        cityHall: {
          select: {
            id: true,
          },
        },

        createdAt: true,
        createdBy: true,
        description: true,
        id: true,
        name: true,
        status: true,
        updatedAt: true,
        videoUrl: true,
      },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get()
  @swagger.ApiOkResponse({ type: [Project] })
  @ApiNestedQuery(ProjectFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "read",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async projects(@common.Req() request: Request): Promise<any[]> {
    const args = plainToClass(ProjectFindManyArgs, request.query);
    
    // Determine requester and scope by cityHall for non-admins
    const authUser = (request as any).user as { id: string; roles: string[] };
    const scopedWhere = await applyEntityScope(this.prisma, authUser, args.where as any);

    // Ensure no status filter unless explicitly provided (return all projects)
    // Add default sorting by createdAt descending (newest first) if no orderBy specified
    const projects = await this.service.projects({
      ...args,
      // Remove any default status filtering - return all projects unless explicitly filtered
      where: scopedWhere,
      // Default to newest first if no orderBy is specified
      orderBy: args.orderBy || [{ createdAt: 'desc' }],
      select: {
        assignedUser: true,

        cityHall: {
          select: {
            id: true,
            name: true,
            description: true,
            allowVideo: true,
            allowImages: true,
            createdAt: true,
            updatedAt: true,
          },
        },

        createdAt: true,
        createdBy: true,
        description: true,
        id: true,
        name: true,
        status: true,
        updatedAt: true,
        videoUrl: true,
        surveys: {
          select: {
            id: true,
            name: true,
            status: true,
            startTime: true,
            endTime: true,
            geometryJson: true,
            bbox: true,
            eIriAvg: true,
            lengthMeters: true,
            createdAt: true,
            updatedAt: true,
          },
        },
        routePoints: {
          select: {
            id: true,
            latitude: true,
            longitude: true,
            timestamp: true,
            frameNumber: true,
            createdAt: true,
            updatedAt: true,
          },
        },
        hazards: {
          select: {
            id: true,
            latitude: true,
            longitude: true,
            description: true,
            severity: true,
            typeField: true,
            imageUrl: true,
            createdAt: true,
            updatedAt: true,
          },
        },
      },
    });

    // Fetch user details for createdBy and assignedUser
    const userIds = new Set<string>();
    projects.forEach((project: any) => {
      if (project.createdBy) userIds.add(project.createdBy);
      if (project.assignedUser) userIds.add(project.assignedUser);
    });

    const users = await this.prisma.user.findMany({
      where: { id: { in: Array.from(userIds) } },
      select: {
        id: true,
        username: true,
        firstName: true,
        lastName: true,
        email: true,
      },
    });

    const userMap = new Map(users.map(u => [u.id, u]));

    // Enrich projects with user information
    return projects.map((project: any) => ({
      ...project,
      createdByUser: project.createdBy ? userMap.get(project.createdBy) || null : null,
      assignedUserInfo: project.assignedUser ? userMap.get(project.assignedUser) || null : null,
    }));
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id")
  @swagger.ApiOkResponse({ type: Project })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "read",
    possession: "own",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async project(
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<any | null> {
    // Determine requester and scope access for non-admins
    const request = (arguments[0] as any) as Request | undefined;
    let whereClause: any = params;
    try {
      // attempt to read user from request context
      // note: in Nest, switchToHttp isn't available here, so rely on interceptor-populated request arg when present
      const reqUser = (request as any)?.user as { id: string; roles: string[] } | undefined;
      const isAdmin = isAdminUser(reqUser);
      if (!isAdmin && reqUser?.id) {
        whereClause = await applyEntityScope(this.prisma, reqUser, whereClause as any);
      }
    } catch (_) {
      // fall back to unscoped where if user not available
    }

    const result = await this.service.project({
      where: whereClause,
      select: {
        assignedUser: true,

        cityHall: {
          select: {
            id: true,
            name: true,
            description: true,
            allowVideo: true,
            allowImages: true,
            createdAt: true,
            updatedAt: true,
          },
        },

        createdAt: true,
        createdBy: true,
        description: true,
        id: true,
        name: true,
        status: true,
        updatedAt: true,
        videoUrl: true,
        surveys: {
          select: {
            id: true,
            name: true,
            status: true,
            startTime: true,
            endTime: true,
            geometryJson: true,
            bbox: true,
            eIriAvg: true,
            lengthMeters: true,
            createdAt: true,
            updatedAt: true,
          },
        },
        routePoints: {
          select: {
            id: true,
            latitude: true,
            longitude: true,
            frameNumber: true,
            timestamp: true,
            createdAt: true,
            updatedAt: true,
          },
        },
        hazards: {
          select: {
            id: true,
            typeField: true,
            severity: true,
            description: true,
            latitude: true,
            longitude: true,
            imageUrl: true,
            createdAt: true,
            updatedAt: true,
          },
        },
      },
    });
    if (result === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }

    // Fetch user details for createdBy and assignedUser
    const userIds: string[] = [];
    if ((result as any).createdBy) userIds.push((result as any).createdBy);
    if ((result as any).assignedUser) userIds.push((result as any).assignedUser);

    let createdByUser = null;
    let assignedUserInfo = null;

    if (userIds.length > 0) {
      const users = await this.prisma.user.findMany({
        where: { id: { in: userIds } },
        select: {
          id: true,
          username: true,
          firstName: true,
          lastName: true,
          email: true,
        },
      });

      const userMap = new Map(users.map(u => [u.id, u]));
      createdByUser = (result as any).createdBy ? userMap.get((result as any).createdBy) || null : null;
      assignedUserInfo = (result as any).assignedUser ? userMap.get((result as any).assignedUser) || null : null;
    }

    return {
      ...result,
      createdByUser,
      assignedUserInfo,
    };
  }

  @common.UseInterceptors(AclValidateRequestInterceptor)
  @common.Patch("/:id")
  @swagger.ApiOkResponse({ type: Project })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async updateProject(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() data: ProjectUpdateInput
  ): Promise<Project | null> {
    try {
      return await this.service.updateProject({
        where: params,
        data: {
          ...data,

          cityHall: data.cityHall
            ? {
                connect: data.cityHall,
              }
            : undefined,
        },
        select: {
          assignedUser: true,

          cityHall: {
            select: {
              id: true,
            },
          },

          createdAt: true,
          createdBy: true,
          description: true,
          id: true,
          name: true,
          status: true,
          updatedAt: true,
          videoUrl: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.Delete("/:id")
  @swagger.ApiOkResponse({ type: Project })
  @swagger.ApiNotFoundResponse({ type: errors.NotFoundException })
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "delete",
    possession: "any",
  })
  @swagger.ApiForbiddenResponse({
    type: errors.ForbiddenException,
  })
  async deleteProject(
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<Project | null> {
    try {
      return await this.service.deleteProject({
        where: params,
        select: {
          assignedUser: true,

          cityHall: {
            select: {
              id: true,
            },
          },

          createdAt: true,
          createdBy: true,
          description: true,
          id: true,
          name: true,
          status: true,
          updatedAt: true,
          videoUrl: true,
        },
      });
    } catch (error) {
      if (isRecordNotFoundError(error)) {
        throw new errors.NotFoundException(
          `No resource was found for ${JSON.stringify(params)}`
        );
      }
      throw error;
    }
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/hazards")
  @ApiNestedQuery(HazardFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Hazard",
    action: "read",
    possession: "any",
  })
  async findHazards(
    @common.Req() request: Request,
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<Hazard[]> {
    const query = plainToClass(HazardFindManyArgs, request.query);
    const results = await this.service.findHazards(params.id, {
      ...query,
      select: {
        createdAt: true,
        createdBy: true,
        description: true,
        id: true,
        imageUrl: true,
        latitude: true,
        longitude: true,

        project: {
          select: {
            id: true,
          },
        },

        routePoint: {
          select: {
            id: true,
          },
        },

        severity: true,
        typeField: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/hazards")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async connectHazards(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: HazardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hazards: {
        connect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/hazards")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async updateHazards(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: HazardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hazards: {
        set: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/hazards")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async disconnectHazards(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: HazardWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      hazards: {
        disconnect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/routePoints")
  @ApiNestedQuery(RoutePointFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "RoutePoint",
    action: "read",
    possession: "any",
  })
  async findRoutePoints(
    @common.Req() request: Request,
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<RoutePoint[]> {
    const query = plainToClass(RoutePointFindManyArgs, request.query);
    const results = await this.service.findRoutePoints(params.id, {
      ...query,
      select: {
        createdAt: true,
        frameNumber: true,
        id: true,
        latitude: true,
        longitude: true,

        project: {
          select: {
            id: true,
          },
        },

        timestamp: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/routePoints")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async connectRoutePoints(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: RoutePointWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routePoints: {
        connect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/routePoints")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async updateRoutePoints(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: RoutePointWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routePoints: {
        set: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/routePoints")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async disconnectRoutePoints(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: RoutePointWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      routePoints: {
        disconnect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.UseInterceptors(AclFilterResponseInterceptor)
  @common.Get("/:id/surveys")
  @ApiNestedQuery(SurveyFindManyArgs)
  @nestAccessControl.UseRoles({
    resource: "Survey",
    action: "read",
    possession: "any",
  })
  async findSurveys(
    @common.Req() request: Request,
    @common.Param() params: ProjectWhereUniqueInput
  ): Promise<Survey[]> {
    const query = plainToClass(SurveyFindManyArgs, request.query);
    const results = await this.service.findSurveys(params.id, {
      ...query,
      select: {
        assignedUser: true,
        createdAt: true,
        endTime: true,
        id: true,
        name: true,

        project: {
          select: {
            id: true,
          },
        },

        remarks: true,
        startTime: true,
        status: true,
        updatedAt: true,
      },
    });
    if (results === null) {
      throw new errors.NotFoundException(
        `No resource was found for ${JSON.stringify(params)}`
      );
    }
    return results;
  }

  @common.Post("/:id/surveys")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async connectSurveys(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: SurveyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      surveys: {
        connect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Patch("/:id/surveys")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async updateSurveys(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: SurveyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      surveys: {
        set: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }

  @common.Delete("/:id/surveys")
  @nestAccessControl.UseRoles({
    resource: "Project",
    action: "update",
    possession: "any",
  })
  async disconnectSurveys(
    @common.Param() params: ProjectWhereUniqueInput,
    @common.Body() body: SurveyWhereUniqueInput[]
  ): Promise<void> {
    const data = {
      surveys: {
        disconnect: body,
      },
    };
    await this.service.updateProject({
      where: params,
      data,
      select: { id: true },
    });
  }
}
